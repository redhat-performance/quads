#!/bin/bash
#set -e
if [ ! -e $(dirname $0)/load-config.sh ]; then
    echo "$(basename $0): could not find load-config.sh"
    exit 1
fi
source $(dirname $0)/load-config.sh
quads=${quads["install_dir"]}/bin/quads.py
openstack_installer=${quads["install_dir"]}/bin/openstack.py
install_dir=${quads["install_dir"]}
bin_dir=${quads["install_dir"]}/bin
data_dir=${quads["data_dir"]}
infrared_dir=${quads["infrared_directory"]}
ssh_priv_key=${quads["private_key_location"]}
json_web_path=${quads["json_web_path"]}
openstack_templates_dir=${quads["openstack_templates"]}
openstack_templates_git=https://github.com/smalleni/automated-openstack-templates.git

#########################################################################################################################


# trap to make sure sure we keep status of deployment
# the start state file is deleted whenever this script exists
# So the start state file is not present if an overcloud was successfully
# deployed or not. It being present indicates that a deployment for this cloud
# is currently running

function finish {
  if [ -f "${data_dir}/postconfig/${env}-${owner}-${ticket}-${config}-start" ]; then
      echo "removing start state as script failed"
      rm "${data_dir}/postconfig/${env}-${owner}-${ticket}-${config}-start"
  fi
}
trap finish EXIT

# function that sets up infrared and does the undercloud and overcloud deploy
# arguments passed to this are cloudname, path to instackenv.json generated by
# QUADS and directory of deployment files

function apply_post_config() {
   echo "$1 needs post config, applying"
   # install and set up directory for infrared
   setup_infrared
   # go into infrared working directory
   pushd $infrared_dir/infrared
   # activate the venv for infrared
   source .venv/bin/activate
   # delete any workspaces existing for this cloud
   delete_workspace $1
   # create new workspace
   create_workspace $1
   # undercloud is the first host returned
   undercloud=$($quads --cloud-only $1 | head -1)
   setup_inventory $1 $undercloud
   # Get version of OSP from schedule.yaml using the $openstack_installer script
   version=$($openstack_installer -c $1 -q | head -1)
   # Get build of OSP from schedule.yaml using the $openstack_installer script
   build=$($openstack_installer -c $1 -q | tail -1)
   ## check if undercloud hasn't been built, if so build it
   if [ ! -f "${data_dir}/postconfig/${env}-${owner}-${ticket}-${config}-undercloud" ]; then
       build_undercloud $1 $version $build $undercloud
   fi
   # get overcloud images
   download_images $1
   # schedule nodes using the $openstack_installer script
   schedule_nodes $1 $2 $3
   # introspect nodes
   introspect $1 ${3}/instackenv.json $3
   # wait for nodes to be introspected and cleaned; need more comprehensive checks in the future
   sleep 1800
   deploy_overcloud $1 "${3}/instackenv.json" $3 $version
}



# function that instructs infrared to deploy with the right arguments
# arguments passed to it are cloudname, instackenv.json generated by
# $openstack_installer script and folder containing deployment files
function deploy_overcloud() {
   IR_WORKSPACE=$1 ir tripleo-overcloud --introspect yes --tag yes --deploy yes --version $4 --instackenv-file $2 --deployment-files $3
   if [ "$?" -eq 0 ]; then
       touch "${data_dir}/postconfig/${env}-${owner}-${ticket}-${1}-overcloud"
   fi

}


# function to introspect
# arguments passed are cloudname, instackenv.json generated by
# $openstack_installer
function introspect() {
    IR_WORKSPACE=$1 ir tripleo-overcloud --introspect yes --tag yes --version $version --instackenv-file $2 --deployment-files $3
}


# downloads overcloud images
# argument passed is cloudnmae for workspace
function download_images() {
    IR_WORKSPACE=$1 ir tripleo-undercloud --images-task rpm
}

# Schedule nodes into roles and generate templatized templates
# arguments passed are cloudname, instackenv.json file generated by QUADS,
# directory of templatized templates and undercloud hostname
function schedule_nodes() {
     echo "Scheduling nodes using the Python Scheduling script"
     $openstack_installer -c $1 -i $2 -t $3 -uc $undercloud

 }

# deploy undercloud through infrared by passing the right arguments
# arguments passed are cloudname, version of OSP and build
function deploy_undercloud() {
     echo "Deploying undercloud"
     RETRY=0
     IR_WORKSPACE=$1 ir tripleo-undercloud $2 --build $3 --config-options DEFAULT.local_interface=em2 --config-options \
     DEFAULT.clean_nodes=true
     while [ "$RETRY" -lt 2 ]
         do
             IR_WORKSPACE=$1 ir tripleo-undercloud $2 --build $3 --config-options DEFAULT.local_interface=em2 --config-options \
             DEFAULT.clean_nodes=true
             # if undercloud install failed, rebuild host and retry
             if [ "$?" != 0 ]; then
                 hammer host update --name $4 --build 1
                 ipmitool -I lanplus -H mgmt-${4} -U quads -P $ticket chassis power cycle
                 sleep 1200
                 IR_WORKSPACE=$1 ir tripleo-undercloud $2 --build $3 --config-options DEFAULT.local_interface=em2 --config-options \
                 DEFAULT.clean_nodes=true
                 RETRY=$((RETRY+1))
             # if undercloud install succeeeded build the undercloud state file
             else
                 touch "${data_dir}/postconfig/${env}-${owner}-${ticket}-${config}-undercloud"
                 break
             fi
        done
}



# since our workspace name is just cloudname we will keep reusing names, so we
# need to delete existing workspaces, export them and start fresh
function delete_workspace() {
    workspace=$(ir workspace list | grep -q $1)
    if [ "$workspace" != "" ]; then
        if [ ! -d $infrared_dir/backup ]; then
           mkdir $infrared_dir/backup
        fi
    infrared workspace export $1 --dest $infrared_dir/backup/$1-$(date +"%s")
    infrared workspace cleanup $1
    fi
}



# Create workspace for infrared specific to cloudname
function create_workspace() {
    echo "Creating infrared workspace $1"
    infrared workspace create $1
}


# sets up inventory for infrared to use
# arguments passed are cloudname and undercloud hostname
function setup_inventory() {
echo "Setting up inventory for cloud $1 with undercloud host $2"
    cat <<EOF > $infrared_dir/infrared/.workspaces/$1/hosts
$2 ansible_ssh_host=$2 ansible_ssh_user=root ansible_ssh_private_key_file=$ssh_priv_key
localhost ansible_connection=local ansible_python_interpreter=python

[undercloud]
$2

[local]
localhost
EOF
}

# Installs and sets up infrared on the QUADS host if its hasn't been done

function setup_infrared() {
    echo "Setting up infrared"
    if [ ! -d ${infrared_dir}/infrared ]; then
        git clone https://github.com/redhat-openstack/infrared.git $infrared_dir/infrared
    fi
    ir workspace list
    if [ "$?" != 0 ]; then
        pushd $infrared_dir/infrared
        virtualenv .venv && source .venv/bin/activate
        pip install --upgrade pip
        pip install --upgrade setuptools
        pip install .
        popd
    fi

}

############################################################################################################################################################

# Pass "openstack" as 1st argument to this script
# set config to "openstack"
if [ "$#" -eq 0 ] ; then
    echo "No arguments passed to this script, so exiting"
    exit 1
fi
config=$1

# Directory for all post-config related state (to track clouds with deployments
# in progress vs undeployed clouds vs clouds that have had successful
# deployments)
if [ ! -d ${data_dir}/postconfig ]; then
    mkdir ${data_dir}/postconfig
fi
# Cycle through all environment that have post-config set to openstack
for env in $($quads --summary --post-config $config); do
    echo "$env needs $1"
    owner=$($quads --ls-owner --cloud-only $env)
    ticket=$($quads --ls-ticket --cloud-only $env)
    # check if this is a valid cloud with owner etc
    if [ "$owner" != "nobody" -a "$owner" -a "$ticket" ]; then
        # check if verifications have passed and environment has been released
        echo "${data_dir}/release/${env}-${owner}-${ticket}"
        if [ -f "${data_dir}/release/${env}-${owner}-${ticket}" ]; then
            echo "Environment $env has been released"
            # check that a deploy is neither in progress nor completed for
            # this cloud; if the start state file isnt present it either means a
            # deploy was never attempted or a deployment attempt failed. We only
            # need to attempt the deployment if it failed (given the start state
            # file isn't present, as any exit from this script successful or not
            # will delete the start state file), so we check for the overcloud
            # state file.  The overcloud state file being absent means either
            # undercloud or overcloud deploy failed. In apply_post_config we try
            # undercloud deploy only after checking that the undercloud state
            # file is absent
            if [ ! -f "${data_dir}/postconfig/${env}-${owner}-${ticket}-${config}-start" ] &&
                   [ ! -f "${data_dir}/postconfig/${env}-${owner}-${ticket}-${config}-overcloud" ]; then
                # touch start state file to indicate a deployment is being
                # tried/retried
                echo "Deploying $1 on $env"
                touch "${data_dir}/postconfig/${env}-${owner}-${ticket}-${1}-start"
                # Setup folder name for templates
               if [ ! -d ${openstack_templates_dir} ]; then
                   echo "Making OpenStack templates directory at ${openstack_templates_dir}"
                   mkdir ${openstack_templates_dir}
               fi
                cloud_specific_templates="${openstack_templates_dir}/${env}-${owner}-${ticket}/automated-openstack-templates"
                # delete folder if it exists as it could have been  created by
                # an earlier attempt
                if [ -d ${cloud_specific_templates} ]; then
                    echo "Deleting preexisting cloud specific templates at ${cloud_specific_templates}"
                    rm -rf ${cloud_specific_templates}
                fi
                # create the templates directory
                echo "Creating directory for cloud specific templates at  ${cloud_specific_templates}"
                mkdir ${cloud_specific_templates}
                # clone templatized templates to this directory
                echo "Cloning templatized templates to  $cloud_specific_templates"
                git clone  https://github.com/smalleni/automated-openstack-templates  $cloud_specific_templates
                # call function that sets up infrared, bilds undercloud,
                # schedules nodes and deploys overcloud. We are passing
                # cloudname, path to the dynamix instackenv.json generated by
                # QUADS and the path to the directory containing templatized
                # templates
                apply_post_config $env ${json_web_path}/${env}_instackenv.json ${cloud_specific_templates}
           fi
        fi
    fi
done
